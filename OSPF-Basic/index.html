

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/images/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Song">
  <meta name="keywords" content="计算机网络,Linux,network,服务器,elasticsearch">
  
    <meta name="description" content="为什么需要OSPF？在OSPF出现前，网络上广泛使用RIP（Routing Information Protocol）作为内部网关协议。 由于RIP是基于距离矢量算法的路由协议，存在着收敛慢、路由环路、可扩展性差等问题，所以逐渐被OSPF取代。 OSPF作为基于链路状态的协议，能够解决RIP所面临的诸多问题。此外，OSPF还有以下优点：  OSPF采用组播形式收发报文，这样可以减少对其它不运行OS">
<meta property="og:type" content="article">
<meta property="og:title" content="什么是OSPF?">
<meta property="og:url" content="https://songxwn.com/OSPF-Basic/index.html">
<meta property="og:site_name" content="Song&#96;s Blog">
<meta property="og:description" content="为什么需要OSPF？在OSPF出现前，网络上广泛使用RIP（Routing Information Protocol）作为内部网关协议。 由于RIP是基于距离矢量算法的路由协议，存在着收敛慢、路由环路、可扩展性差等问题，所以逐渐被OSPF取代。 OSPF作为基于链路状态的协议，能够解决RIP所面临的诸多问题。此外，OSPF还有以下优点：  OSPF采用组播形式收发报文，这样可以减少对其它不运行OS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/12/24/e4f471f05c987460.jpg">
<meta property="article:published_time" content="2023-07-30T03:52:00.000Z">
<meta property="article:modified_time" content="2023-07-30T04:38:43.153Z">
<meta property="article:author" content="Song">
<meta property="article:tag" content="network">
<meta property="article:tag" content="datacom">
<meta property="article:tag" content="ospf">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2022/12/24/e4f471f05c987460.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>什么是OSPF? - Song`s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/scroll.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"songxwn.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":100,"cursorChar":"|","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":false,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Song`s Blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Song`s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>主页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/books/">
                <i class="iconfont icon-books"></i>
                <span>读书</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                <span>RSS</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://img.songxwn.com/file/9a6a3f4c572b478a6a538.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="什么是OSPF?"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-30 11:52" pubdate>
          2023年7月30日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          121 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">什么是OSPF?</h1>
            
              <p class="note note-danger">
                
                  
                    本文最后更新于：2023年7月30日 下午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h2 id="为什么需要OSPF？"><a href="#为什么需要OSPF？" class="headerlink" title="为什么需要OSPF？"></a>为什么需要OSPF？</h2><p>在OSPF出现前，网络上广泛使用RIP（Routing Information Protocol）作为内部网关协议。</p>
<p>由于RIP是基于距离矢量算法的路由协议，存在着收敛慢、路由环路、可扩展性差等问题，所以逐渐被OSPF取代。</p>
<p>OSPF作为基于链路状态的协议，能够解决RIP所面临的诸多问题。此外，OSPF还有以下优点：</p>
<ul>
<li>OSPF采用<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/%E7%BB%84%E6%92%AD.html" title="组播">组播</a>形式收发报文，这样可以减少对其它不运行OSPF路由器的影响。</li>
<li>OSPF支持无类型域间选路（CIDR）。</li>
<li>OSPF支持对等价路由进行负载分担。</li>
<li>OSPF支持报文加密。</li>
</ul>
<p>由于OSPF具有以上优势，使得OSPF作为优秀的内部网关协议被快速接收并广泛使用。</p>
<span id="more"></span>

<h2 id="OSPF基础概念"><a href="#OSPF基础概念" class="headerlink" title="OSPF基础概念"></a>OSPF基础概念</h2><h3 id="Router-ID"><a href="#Router-ID" class="headerlink" title="Router ID"></a>Router ID</h3><p>如果要运行OSPF协议，必须存在Router ID。Router ID是一个32比特无符号整数，是一台路由器在自治系统中的唯一标识。</p>
<p>Router ID的设定有两种方式：</p>
<ul>
<li><p>通过命令行手动配置，在实际网络部署中，建议手工配置OSPF的Router ID，因为这关系到协议的稳定。</p>
</li>
<li><p>通过协议自动选取。</p>
<p>如果没有手动配置Router ID，设备会从当前接口的IP地址中自动选取一个作为Router ID。其选取顺序是：</p>
<ol>
<li><p>优先从Loopback地址中选择最大的IP地址作为Router ID。</p>
</li>
<li><p>如果没有配置Loopback接口，则在接口地址中选取最大的IP地址作为Router ID。</p>
</li>
</ol>
</li>
</ul>
<p>在路由器运行了OSPF并确定了Router ID后，如果该Router ID对应的接口Down或者接口消失（例如执行了<strong>undo interface loopback</strong> _loopback-number_）或者出现更大的IP地址，OSPF将仍然保持原Router ID。只有重新配置系统的Router ID或者OSPF的Router ID，并且重新启动OSPF进程后，才会进行Router ID的重新选取。</p>
<h3 id="链路状态"><a href="#链路状态" class="headerlink" title="链路状态"></a>链路状态</h3><p>OSPF是一种链路状态协议。可以将链路视为路由器的接口。链路状态是对接口及接口与相邻路由器的关系的描述。例如接口的信息包括接口的IP地址、掩码、所连接的网络的类型、连接的邻居等。所有这些链路状态的集合形成链路状态数据库。</p>
<h3 id="COST"><a href="#COST" class="headerlink" title="COST"></a>COST</h3><ul>
<li><p>OSPF使用cost“开销”作为路由度量值。</p>
</li>
<li><p>每一个激活OSPF的接口都有一个cost值。OSPF接口cost&#x3D;100M&#x2F;接口带宽，其中100M为OSPF的参考带宽（reference-bandwidth）。</p>
</li>
<li><p>一条OSPF路由的cost由该路由从路由的起源一路到达本地的所有入接口cost值的总和。</p>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=4d039cad0996458293e1ef379d855fed" srcset="/img/loading.gif" lazyload></p>
<p>由于默认的参考带宽是100M，这意味着更高带宽的传输介质（高于100M）在OSPF协议中将会计算出一个小于1的分数，这在OSPF协议中是不允许的（会被四舍五入为1）。而现今网络设备很多都是大于100M带宽的接口，这时候路由cost的计算其实就不精确了。所以可以使用<strong>bandwidth-reference</strong>命令修改，但是这条命令要谨慎使用，一旦要配置，则建议全网OSPF路由器都配置。</p>
</li>
</ul>
<h3 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h3><p>表1-1 报文类型</p>
<p>|<br>报文类型</p>
<p> | </p>
<p>报文作用</p>
<p> |<br>| — | — |<br>| </p>
<p>Hello报文</p>
<p> | </p>
<p>周期性发送，用来发现和维持OSPF邻居关系。</p>
<p> |<br>| </p>
<p>DD报文（Database Description packet）</p>
<p> | </p>
<p>描述本地LSDB（Link State Database）的摘要信息，用于两台设备进行数据库同步。</p>
<p> |<br>| </p>
<p>LSR报文（Link State Request packet）</p>
<p> | </p>
<p>用于向对方请求所需的LSA。</p>
<p>设备只有在OSPF邻居双方成功交换DD报文后才会向对方发出LSR报文。</p>
<p> |<br>| </p>
<p>LSU报文（Link State Update packet）</p>
<p> | </p>
<p>用于向对方发送其所需要的LSA。</p>
<p> |<br>| </p>
<p>LSAck报文（Link State Acknowledgment packet）</p>
<p> | </p>
<p>用来对收到的LSA进行确认。</p>
<p> |</p>
<h3 id="LSA类型"><a href="#LSA类型" class="headerlink" title="LSA类型"></a>LSA类型</h3><p>表1-2 LSA类型</p>
<p>|<br>LSA类型</p>
<p> | </p>
<p>LSA作用</p>
<p> |<br>| — | — |<br>| </p>
<p>Router-LSA（Type1）</p>
<p> | </p>
<p>每个设备都会产生，描述了设备的链路状态和开销，在所属的区域内传播。</p>
<p> |<br>| </p>
<p>Network-LSA（Type2）</p>
<p> | </p>
<p>由DR（Designated Router）产生，描述本网段的链路状态，在所属的区域内传播。</p>
<p> |<br>| </p>
<p>Network-summary-LSA（Type3）</p>
<p> | </p>
<p>由ABR产生，描述区域内某个网段的路由，并通告给发布或接收此LSA的非Totally STUB或NSSA区域。例如：ABR同时属于Area0和Area1，Area0内存在网段10.1.1.0，Area1内存在网段11.1.1.0，ABR为Area0生成到网段11.1.1.0的Type3 LSA；ABR为Area1生成到网段10.1.1.0的Type3 LSA，并通告给发布或接收此LSA的非Totally Stub或NSSA区域。</p>
<p> |<br>| </p>
<p>ASBR-summary-LSA（Type4）</p>
<p> | </p>
<p>由ABR产生，描述到ASBR的路由，通告给除ASBR所在区域的其他相关区域。</p>
<p> |<br>| </p>
<p>AS-external-LSA（Type5）</p>
<p> | </p>
<p>由ASBR产生，描述到AS外部的路由，通告到所有的区域（除了STUB区域和NSSA区域）。</p>
<p> |<br>| </p>
<p>NSSA LSA（Type7）</p>
<p> | </p>
<p>由ASBR产生，描述到AS外部的路由，仅在NSSA区域内传播。</p>
<p> |<br>| </p>
<p>Opaque LSA（Type9&#x2F;Type10&#x2F;Type11）</p>
<p> | </p>
<p>Opaque LSA提供用于OSPF的扩展的通用机制。其中：</p>
<ul>
<li>Type9 LSA仅在接口所在网段范围内传播。用于支持GR的Grace LSA就是Type9 LSA的一种。</li>
<li>Type10 LSA在区域内传播。用于支持TE的LSA就是Type10 LSA的一种。</li>
<li>Type11 LSA在自治域内传播，目前还没有实际应用的例子。</li>
</ul>
<p> |</p>
<h3 id="LSA在各区域中传播的支持情况"><a href="#LSA在各区域中传播的支持情况" class="headerlink" title="LSA在各区域中传播的支持情况"></a>LSA在各区域中传播的支持情况</h3><p>表1-3 LSA在各区域中传播的支持情况</p>
<p>|<br>区域类型</p>
<p> | </p>
<p>Router-LSA（Type1）</p>
<p> | </p>
<p>Network-LSA（Type2）</p>
<p> | </p>
<p>Network-summary-LSA（Type3）</p>
<p> | </p>
<p>ASBR-summary-LSA（Type4）</p>
<p> | </p>
<p>AS-external-LSA（Type5）</p>
<p> | </p>
<p>NSSA LSA（Type7）</p>
<p> |<br>| — | — | — | — | — | — | — |<br>| </p>
<p>普通区域（包括标准区域和骨干区域）</p>
<p> | </p>
<p>是</p>
<p> | </p>
<p>是</p>
<p> | </p>
<p>是</p>
<p> | </p>
<p>是</p>
<p> | </p>
<p>是</p>
<p> | </p>
<p>否</p>
<p> |<br>| </p>
<p>Stub区域</p>
<p> | </p>
<p>是</p>
<p> | </p>
<p>是</p>
<p> | </p>
<p>是</p>
<p> | </p>
<p>否</p>
<p> | </p>
<p>否</p>
<p> | </p>
<p>否</p>
<p> |<br>| </p>
<p>Totally Stub区域</p>
<p> | </p>
<p>是</p>
<p> | </p>
<p>是</p>
<p> | </p>
<p>否</p>
<p> | </p>
<p>否</p>
<p> | </p>
<p>否</p>
<p> | </p>
<p>否</p>
<p> |<br>| </p>
<p>NSSA区域</p>
<p> | </p>
<p>是</p>
<p> | </p>
<p>是</p>
<p> | </p>
<p>是</p>
<p> | </p>
<p>否</p>
<p> | </p>
<p>否</p>
<p> | </p>
<p>是</p>
<p> |<br>| </p>
<p>Totally NSSA区域</p>
<p> | </p>
<p>是</p>
<p> | </p>
<p>是</p>
<p> | </p>
<p>否</p>
<p> | </p>
<p>否</p>
<p> | </p>
<p>否</p>
<p> | </p>
<p>是</p>
<p> |</p>
<h3 id="路由器类型"><a href="#路由器类型" class="headerlink" title="路由器类型"></a>路由器类型</h3><p>OSPF协议中常用到的路由器类型如图所示。</p>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=a1b351c20c5748b9b00f0b1d8277e33e" srcset="/img/loading.gif" lazyload alt="路由器类型" title="路由器类型"><br>路由器类型</p>
<p>表1-4 路由器类型</p>
<p>|<br>路由器类型</p>
<p> | </p>
<p>含义</p>
<p> |<br>| — | — |<br>| </p>
<p>区域内路由器（Internal Router）</p>
<p> | </p>
<p>该类设备的所有接口都属于同一个OSPF区域。</p>
<p> |<br>| </p>
<p>区域边界路由器ABR（Area Border Router）</p>
<p> | </p>
<p>该类设备可以同时属于两个以上的区域，但其中一个必须是骨干区域。</p>
<p>ABR用来连接骨干区域和非骨干区域，它与骨干区域之间既可以是物理连接，也可以是逻辑上的连接。</p>
<p> |<br>| </p>
<p>骨干路由器（Backbone Router）</p>
<p> | </p>
<p>该类设备至少有一个接口属于骨干区域。</p>
<p>所有的ABR和位于Area0的内部设备都是骨干路由器。</p>
<p> |<br>| </p>
<p>自治系统边界路由器ASBR（AS Boundary Router）</p>
<p> | </p>
<p>与其他AS交换路由信息的设备称为ASBR。</p>
<p>ASBR并不一定位于AS的边界，它可能是区域内设备，也可能是ABR。只要一台OSPF设备引入了外部路由的信息，它就成为ASBR。</p>
<p> |</p>
<h3 id="路由类型"><a href="#路由类型" class="headerlink" title="路由类型"></a>路由类型</h3><p>AS区域内和区域间路由描述的是AS内部的网络结构，AS外部路由则描述了应该如何选择到AS以外目的地址的路由。OSPF将引入的AS外部路由分为Type1和Type2两类。</p>
<p>如下表中按优先级从高到低顺序列出了路由类型。</p>
<p>表1-5 路由类型</p>
<p>|<br>路由类型</p>
<p> | </p>
<p>含义</p>
<p> |<br>| — | — |<br>| </p>
<p>Intra Area</p>
<p> | </p>
<p>区域内路由。</p>
<p> |<br>| </p>
<p>Inter Area</p>
<p> | </p>
<p>区域间路由。</p>
<p> |<br>| </p>
<p>第一类外部路由（Type1 External）</p>
<p> | </p>
<p>这类路由的可信程度高一些，所以计算出的外部路由的开销与自治系统内部的路由开销是相当的，并且和OSPF自身路由的开销具有可比性。</p>
<p>到第一类外部路由的开销&#x3D;本设备到相应的ASBR的开销+ASBR到该路由目的地址的开销。</p>
<p> |<br>| </p>
<p>第二类外部路由（Type2 External）</p>
<p> | </p>
<p>这类路由的可信度比较低，所以OSPF协议认为从ASBR到自治系统之外的开销远远大于在自治系统之内到达ASBR的开销。</p>
<p>所以，OSPF计算路由开销时只考虑ASBR到自治系统之外的开销，即到第二类外部路由的开销&#x3D;ASBR到该路由目的地址的开销。</p>
<p> |</p>
<h3 id="区域类型"><a href="#区域类型" class="headerlink" title="区域类型"></a>区域类型</h3><p>表1-6 区域类型</p>
<p>|<br>区域类型</p>
<p> | </p>
<p>作用</p>
<p> |<br>| — | — |<br>| </p>
<p>普通区域</p>
<p> | </p>
<p>缺省情况下，OSPF区域被定义为普通区域。普通区域包括标准区域和骨干区域。</p>
<ul>
<li>标准区域是最通用的区域，它传输区域内路由，区域间路由和外部路由。</li>
<li>骨干区域是连接所有其他OSPF区域的中央区域。骨干区域通常用Area 0表示。</li>
</ul>
<p> |<br>| </p>
<p>STUB区域</p>
<p> | </p>
<p>不允许发布自治系统外部路由，只允许发布区域内路由和区域间的路由。</p>
<p>在STUB区域中，路由器的路由表规模和路由信息传递的数量都会大大减少。</p>
<p>为了保证到自治系统外的路由可达，由该区域的ABR发布Type3缺省路由传播到区域内，所有到自治系统外部的路由都必须通过ABR才能发布。</p>
<p> |<br>| </p>
<p>Totally STUB区域</p>
<p> | </p>
<p>不允许发布自治系统外部路由和区域间的路由，只允许发布区域内路由。</p>
<p>在Totally STUB区域中，路由器的路由表规模和路由信息传递的数量都会大大减少。</p>
<p>为了保证到自治系统外和其他区域的路由可达，由该区域的ABR发布Type3缺省路由传播到区域内，所有到自治系统外部和其他区域的路由都必须通过ABR才能发布。</p>
<p> |<br>| </p>
<p>NSSA区域</p>
<p> | </p>
<p>NSSA区域允许引入自治系统外部路由，由ASBR发布Type7 LSA通告给本区域，这些Type7 LSA在ABR上转换成Type5 LSA，并且泛洪到整个OSPF域中。</p>
<p>NSSA区域同时保留自治系统内的STUB区域的特征。</p>
<p>该区域的ABR发布Type7缺省路由传播到区域内，所有域间路由都必须通过ABR才能发布。</p>
<p> |<br>| </p>
<p>Totally NSSA区域</p>
<p> | </p>
<p>Totally NSSA区域允许引入自治系统外部路由，由ASBR发布Type7 LSA通告给本区域，这些Type7 LSA在ABR上转换成Type5 LSA，并且泛洪到整个OSPF域中。</p>
<p>Totally NSSA区域同时保留自治系统内的Totally STUB Area区域的特征。</p>
<p>该区域的ABR发布Type3和Type7缺省路由传播到区域内，所有域间路由都必须通过ABR才能发布。</p>
<p> |</p>
<h3 id="OSPF支持的网络类型"><a href="#OSPF支持的网络类型" class="headerlink" title="OSPF支持的网络类型"></a>OSPF支持的网络类型</h3><p>OSPF根据链路层协议类型，将网络分为如下表所列四种类型。</p>
<p>表1-7 OSPF网络类型</p>
<p>|<br>网络类型</p>
<p> | </p>
<p>含义</p>
<p> |<br>| — | — |<br>| </p>
<p>广播类型（Broadcast）</p>
<p> | </p>
<p>当链路层协议是Ethernet、FDDI时，缺省情况下，OSPF认为网络类型是Broadcast。</p>
<p>在该类型的网络中：</p>
<ul>
<li>通常以<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/%E7%BB%84%E6%92%AD.html" title="组播">组播</a>形式发送Hello报文、LSU报文和LSAck报文。其中，224.0.0.5的组播地址为OSPF设备的预留<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/%E7%BB%84%E6%92%AD.html" title="组播">IP组播</a>地址；224.0.0.6的组播地址为OSPF DR&#x2F;BDR（ Backup Designated Router）的预留IP组播地址。</li>
<li>以单播形式发送DD报文和LSR报文。</li>
</ul>
<p> |<br>| </p>
<p>NBMA类型（Non-Broadcast Multi-Access）</p>
<p> | </p>
<p>当链路层协议是帧中继、X.25时，缺省情况下，OSPF认为网络类型是NBMA。</p>
<p>在该类型的网络中，以单播形式发送协议报文（Hello报文、DD报文、LSR报文、LSU报文、LSAck报文）。</p>
<p> |<br>| </p>
<p>点到多点P2MP类型（Point-to-Multipoint）</p>
<p> | </p>
<p>没有一种链路层协议会被缺省的认为是Point-to-Multipoint类型。点到多点必须是由其他的网络类型强制更改的。常用做法是将非全连通的NBMA改为点到多点的网络。</p>
<p>在该类型的网络中：</p>
<ul>
<li>以组播形式（224.0.0.5）发送Hello报文。</li>
<li>以单播形式发送其他协议报文（DD报文、LSR报文、LSU报文、LSAck报文）。</li>
</ul>
<p> |<br>| </p>
<p>点到点P2P类型（point-to-point）</p>
<p> | </p>
<p>当链路层协议是PPP、HDLC和LAPB时，缺省情况下，OSPF认为网络类型是P2P。</p>
<p>在该类型的网络中，以组播形式（224.0.0.5）发送协议报文（Hello报文、DD报文、LSR报文、LSU报文、LSAck报文）。</p>
<p> |</p>
<h3 id="DR和BDR"><a href="#DR和BDR" class="headerlink" title="DR和BDR"></a>DR和BDR</h3><p>在广播网和NBMA网络中，任意两台路由器之间都要传递路由信息。如图所示，网络中有n台路由器，则需要建立n*(n-1)&#x2F;2个邻接关系。这使得任何一台路由器的路由变化都会导致多次传递，浪费了带宽资源。为解决这一问题，OSPF定义了指定路由器DR和备份指定路由器BDR。通过选举产生DR（Designated Router）后，所有路由器都只将信息发送给DR，由DR将网络链路状态LSA广播出去。除DR和BDR之外的路由器（称为DR Other）之间将不再建立邻接关系，也不再交换任何路由信息，这样就减少了广播网和NBMA网络上各路由器之间邻接关系的数量。</p>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=cbb680e5ce9649548861b65001616f40" srcset="/img/loading.gif" lazyload alt="选举DR前后对比图" title="选举DR前后对比图"><br>选举DR前后对比图</p>
<p>如果DR由于某种故障而失效，则网络中的路由器必须重新选举DR，并与新的DR同步。这需要较长的时间，在这段时间内，路由的计算有可能是不正确的。为了能够缩短这个过程，OSPF提出了BDR（Backup Designated Router）的概念。BDR是对DR的一个备份，在选举DR的同时也选举出BDR，BDR也和本网段内的所有路由器建立邻接关系并交换路由信息。当DR失效后，BDR会立即成为DR。由于不需要重新选举，并且邻接关系已建立，所以这个过程非常短暂，这时还需要再重新选举出一个新的BDR，虽然一样需要较长的时间，但并不会影响路由的计算。</p>
<p>DR和BDR不是人为指定的，而是由本网段中所有的路由器共同选举出来的。路由器接口的DR优先级决定了该接口在选举DR、BDR时所具有的资格。本网段内DR优先级大于0的路由器都可作为“候选人”。选举中使用的“选票”就是Hello报文。每台路由器将自己选出的DR写入Hello报文中，发给网段上的其他路由器。当处于同一网段的两台路由器同时宣布自己是DR时，DR优先级高者胜出。如果优先级相等，则Router ID大者胜出。如果一台路由器的优先级为0，则它不会被选举为DR或BDR。</p>
<h3 id="STUB区域"><a href="#STUB区域" class="headerlink" title="STUB区域"></a>STUB区域</h3><p>STUB区域是一些特定的区域，STUB区域的ABR不传播它们接收到的自治系统外部路由，在这些区域中路由器的路由表规模以及路由信息传递的数量都会大大减少。</p>
<p>STUB区域是一种可选的配置属性，但并不是每个区域都符合配置的条件。通常来说，STUB区域位于自治系统的边界，是那些只有一个ABR的非骨干区域。</p>
<p>为保证到自治系统外的路由依旧可达，该区域的ABR将生成一条缺省路由，并发布给STUB区域中的其他非ABR路由器。</p>
<p>配置STUB区域时需要注意下列几点：</p>
<ul>
<li>骨干区域不能配置成STUB区域。</li>
<li>如果要将一个区域配置成STUB区域，则该区域中的所有路由器都要配置STUB区域属性。</li>
<li>STUB区域内不能存在ASBR，即自治系统外部的路由不能在本区域内传播。</li>
<li>虚连接不能穿过STUB区域。</li>
</ul>
<h3 id="NSSA区域"><a href="#NSSA区域" class="headerlink" title="NSSA区域"></a>NSSA区域</h3><p>NSSA（Not-So-Stubby Area）区域是OSPF特殊的区域类型。NSSA区域与STUB区域有许多相似的地方，两者都不传播来自OSPF网络其它区域的外部路由。差别在于STUB区域是不能引入外部路由，NSSA区域能够将自治域外部路由引入并传播到整个OSPF自治域中。</p>
<p>当区域配置为NSSA区域后，为保证到自治系统外的路由可达，NSSA区域的ABR将生成一条缺省路由，并发布给NSSA区域中的其他路由器。</p>
<p>配置NSSA区域时需要注意下列几点：</p>
<ul>
<li>骨干区域不能配置成NSSA区域。</li>
<li>如果要将一个区域配置成NSSA区域，则该区域中的所有路由器都要配置NSSA区域属性。</li>
<li>虚连接不能穿过NSSA区域。</li>
</ul>
<h3 id="邻居状态机"><a href="#邻居状态机" class="headerlink" title="邻居状态机"></a>邻居状态机</h3><p>在OSPF网络中，为了交换路由信息，邻居设备之间首先要建立邻接关系，邻居（Neighbors）关系和邻接（Adjacencies）关系是两个不同的概念。</p>
<ul>
<li>邻居关系：OSPF设备启动后，会通过OSPF接口向外发送Hello报文，收到Hello报文的OSPF设备会检查报文中所定义的参数，如果双方一致就会形成邻居关系，两端设备互为邻居。</li>
<li>邻接关系：形成邻居关系后，如果两端设备成功交换DD报文和LSA，才建立邻接关系。</li>
</ul>
<p>OSPF共有8种状态机，分别是：Down、Attempt、Init、2-way、Exstart、Exchange、Loading、Full。</p>
<ul>
<li>Down：邻居会话的初始阶段，表明没有在邻居失效时间间隔内收到来自邻居路由器的Hello数据包。</li>
<li>Attempt：该状态仅发生在NBMA网络中，表明对端在邻居失效时间间隔（dead interval）超时前仍然没有回复Hello报文。此时路由器依然每发送轮询Hello报文的时间间隔（poll interval）向对端发送Hello报文。</li>
<li>Init：收到Hello报文后状态为Init。</li>
<li>2-way：收到的Hello报文中包含有自己的Router ID，则状态为2-way；如果不需要形成邻接关系则邻居状态机就停留在此状态，否则进入Exstart状态。</li>
<li>Exstart：开始协商主从关系，并确定DD的序列号，此时状态为Exstart。</li>
<li>Exchange：主从关系协商完毕后开始交换DD报文，此时状态为Exchange。</li>
<li>Loading：DD报文交换完成即Exchange done，此时状态为Loading。</li>
<li>Full：LSR重传列表为空，此时状态为Full。</li>
</ul>
<h3 id="OSPF报文认证"><a href="#OSPF报文认证" class="headerlink" title="OSPF报文认证"></a>OSPF报文认证</h3><p>OSPF支持报文验证功能，只有通过验证的OSPF报文才能接收，否则将不能正常建立邻居。</p>
<p>路由器支持两种验证方式：</p>
<ul>
<li>区域验证方式</li>
<li>接口验证方式</li>
</ul>
<p>当两种验证方式都存在时，优先使用接口验证方式。</p>
<h3 id="OSPF路由聚合"><a href="#OSPF路由聚合" class="headerlink" title="OSPF路由聚合"></a>OSPF路由聚合</h3><p>路由聚合是指ABR可以将具有相同前缀的路由信息聚合到一起，只发布一条路由到其它区域。</p>
<p>区域间通过路由聚合，可以减少路由信息，从而减小路由表的规模，提高设备的性能。</p>
<p>OSPF有两种路由聚合方式：</p>
<ul>
<li><p>ABR聚合</p>
<p>ABR向其它区域发送路由信息时，以网段为单位生成Type3 LSA。如果该区域中存在一些连续的网段，则可以通过命令将这些连续的网段聚合成一个网段。这样ABR只发送一条聚合后的LSA，所有属于命令指定的聚合网段范围的LSA将不会再被单独发送出去。</p>
</li>
<li><p>ASBR聚合</p>
<p>配置路由聚合后，如果本地设备是自治系统边界路由器ASBR，将对引入的聚合地址范围内的Type5 LSA进行聚合。当配置了NSSA区域时，还要对引入的聚合地址范围内的Type7 LSA进行聚合。</p>
<p>如果本地设备既是ASBR又是ABR，则对由Type7 LSA转化成的Type5 LSA进行聚合处理。</p>
</li>
</ul>
<h3 id="OSPF缺省路由"><a href="#OSPF缺省路由" class="headerlink" title="OSPF缺省路由"></a>OSPF缺省路由</h3><p>缺省路由是指目的地址和掩码都是0的路由。当设备无精确匹配的路由时，就可以通过缺省路由进行报文转发。由于OSPF路由的分级管理，Type3缺省路由的优先级高于Type5或Type7路由。</p>
<p>OSPF缺省路由通常应用于下面两种情况：</p>
<ul>
<li>由区域边界路由器（ABR）发布Type3缺省Summary LSA，用来指导区域内设备进行区域之间报文的转发。</li>
<li>由自治系统边界路由器（ASBR）发布Type5外部缺省ASE LSA，或者Type7外部缺省NSSA LSA，用来指导自治系统（AS）内设备进行自治系统外报文的转发。</li>
</ul>
<p>OSPF缺省路由的发布原则如下：</p>
<ul>
<li>OSPF路由器只有具有对区域外的出口时，才能够发布缺省路由LSA。</li>
<li>如果OSPF路由器已经发布了缺省路由LSA，那么不再学习其它路由器发布的相同类型缺省路由。即路由计算时不再计算其它路由器发布的相同类型的缺省路由LSA，但数据库中存有对应LSA。</li>
<li>外部缺省路由的发布如果要依赖于其它路由，那么被依赖的路由不能是本OSPF路由域内的路由，即不是本进程OSPF学习到的路由。因为外部缺省路由的作用是用于指导报文的域外转发，而本OSPF路由域的路由的下一跳都指向了域内，不能满足指导报文域外转发的要求。</li>
</ul>
<p>不同区域缺省路由发布原则如下表所示。</p>
<p>表1-8 OSPF缺省路由发布原则</p>
<p>|<br>区域类型</p>
<p> | </p>
<p>作用</p>
<p> |<br>| — | — |<br>| </p>
<p>普通区域</p>
<p> | </p>
<p>缺省情况下，普通OSPF区域内的OSPF路由器是不会产生缺省路由的，即使它有缺省路由。</p>
<p>当网络中缺省路由通过其他路由进程产生时，路由器必须将缺省路由通告到整个OSPF自治域中。实现方法是在ASBR上手动通过命令进行配置，产生缺省路由。配置完成后，路由器会产生一个缺省ASE LSA（Type5 LSA），并且通告到整个OSPF自治域中。</p>
<p> |<br>| </p>
<p>STUB区域</p>
<p> | </p>
<p>STUB区域不允许自治系统外部的路由（Type5 LSA）在区域内传播。</p>
<p>区域内的路由器必须通过ABR学到自治系统外部的路由。实现方法是ABR会自动产生一条缺省的Summary LSA（Type3 LSA）通告到整个STUB区域内。这样，到达自治系统的外部路由就可以通过ABR到达。</p>
<p> |<br>| </p>
<p>Totally STUB区域</p>
<p> | </p>
<p>Totally STUB区域既不允许自治系统外部的路由（Type5 LSA）在区域内传播，也不允许区域间路由（Type3 LSA）在区域内传播。</p>
<p>区域内的路由器必须通过ABR学到自治系统外部和其他区域的路由。实现方法是配置Totally STUB区域后，ABR会自动产生一条缺省的Summary LSA（Type3 LSA）通告到整个STUB区域内。这样，到达自治系统外部的路由和其他区域间的路由都可以通过ABR到达。</p>
<p> |<br>| </p>
<p>NSSA区域</p>
<p> | </p>
<p>NSSA区域允许引入通过本区域的ASBR到达的少量外部路由，但不允许其他区域的外部路由ASE LSA（Type5 LSA）在区域内传播。即到达自治系统外部的路由只能通过本区域的ASBR到达。</p>
<p>只配置了NSSA区域是不会自动产生缺省路由的。</p>
<p>此时，有两种选择：</p>
<ul>
<li>如果希望到达自治系统外部的路由通过该区域的ASBR到达，而其它外部路由通过其它区域出去。此时，ABR会产生一条Type7 LSA的缺省路由，通告到整个NSSA区域内。这样，除了某少部分路由通过NSSA的ASBR到达，其它路由都可以通过NSSA的ABR到达其它区域的ASBR出去。</li>
<li>如果希望所有的外部路由只通过本区域NSSA的ASBR到达。则必须在ASBR上手动通过命令进行配置，使ASBR产生一条缺省的NSSA LSA（Type7 LSA），通告到整个NSSA区域内。这样，所有的外部路由就只能通过本区域NSSA的ASBR到达。</li>
</ul>
<p>上面两种情况的区别是：</p>
<ul>
<li>在ABR上无论路由表中是否存在缺省路由0.0.0.0，都会产生Type7 LSA的缺省路由。</li>
<li>在ASBR上只有当路由表中存在缺省路由0.0.0.0时，才会产生Type7 LSA的缺省路由。</li>
</ul>
<p>因为缺省路由只是在本NSSA区域内泛洪，并没有泛洪到整个OSPF域中，所以本NSSA区域内的路由器在找不到路由之后可以从该NSSA的ASBR出去，但不能实现其他OSPF域的路由从这个出口出去。Type7 LSA缺省路由不会在ABR上转换成Type5 LSA缺省路由泛洪到整个OSPF域。</p>
<p> |<br>| </p>
<p>Totally NSSA区域</p>
<p> | </p>
<p>Totally NSSA区域既不允许其他区域的外部路由ASE LSA（Type5 LSA）在区域内传播，也不允许区域间路由（Type3 LSA）在区域内传播。</p>
<p>区域内的路由器必须通过ABR学到其他区域的路由。实现方法是配置Totally NSSA区域后，ABR会自动产生一条缺省的Type3 LSA通告到整个NSSA区域内。这样，其他区域的外部路由和区域间路由都可以通过ABR在区域内传播。</p>
<p> |</p>
<h3 id="OSPF路由过滤"><a href="#OSPF路由过滤" class="headerlink" title="OSPF路由过滤"></a>OSPF路由过滤</h3><p>OSPF支持使用路由策略对路由信息进行过滤。缺省情况下，OSPF不进行路由过滤。</p>
<p>OSPF可以使用的路由策略包括route-policy，访问控制列表（access-list），地址前缀列表（prefix-list）。</p>
<p>OSPF路由过滤可以应用于以下几个方面：</p>
<ul>
<li><p>路由引入</p>
<p>OSPF可以引入其它路由协议学习到的路由。在引入时可以通过配置路由策略来过滤路由，只引入满足条件的路由。</p>
</li>
<li><p>引入路由发布</p>
<p>OSPF引入了路由后会向其它邻居发布引入的路由信息。</p>
<p>可以通过配置过滤规则来过滤向邻居发布的路由信息。该过滤规则只在ASBR上配置才有效。</p>
</li>
<li><p>路由学习</p>
<p>通过配置过滤规则，可以设置OSPF对接收到的区域内、区域间和自治系统外部的路由进行过滤。</p>
<p>该过滤只作用于路由表项的添加与否，即只有通过过滤的路由才被添加到本地路由表中，但所有的路由仍可以在OSPF路由表中被发布出去。</p>
</li>
<li><p>区域间LSA学习</p>
<p>通过命令可以在ABR上配置对进入本区域的Summary LSA进行过滤。该配置只在ABR上有效（只有ABR才能发布Summary LSA）。</p>
</li>
</ul>
<p>表1-9 区域间LSA学习与路由学习的差异</p>
<p>|<br>区域间LSA学习</p>
<p> | </p>
<p>路由学习</p>
<p> |<br>| — | — |<br>| </p>
<p>直接对进入区域的LSA进行过滤。</p>
<p> | </p>
<p>路由学习中的过滤不对LSA进行过滤，只针对LSA计算出来的路由是否添加本地路由表进行过滤。学习到的LSA是完整的。</p>
<p> |</p>
<ul>
<li><p>区域间LSA发布</p>
<p>通过命令可以在ABR上配置对本区域出方向的Summary LSA进行过滤。该配置只在ABR上配置有效。</p>
</li>
</ul>
<h3 id="OSPF多进程"><a href="#OSPF多进程" class="headerlink" title="OSPF多进程"></a>OSPF多进程</h3><p>OSPF支持多进程，在同一台路由器上可以运行多个不同的OSPF进程，它们之间互不影响，彼此独立。不同OSPF进程之间的路由交互相当于不同路由协议之间的路由交互。</p>
<p>路由器的一个接口只能属于某一个OSPF进程。</p>
<p>OSPF多进程的一个典型应用就是在VPN场景中PE和CE之间运行OSPF协议，同时VPN骨干网上的IGP也采用OSPF。在PE上，这两个OSPF进程互不影响。</p>
<h3 id="OSPF-RFC1583兼容"><a href="#OSPF-RFC1583兼容" class="headerlink" title="OSPF RFC1583兼容"></a>OSPF RFC1583兼容</h3><p>RFC1583是OSPFv2协议比较早的版本。</p>
<p>OSPF在计算外部路由时，由于RFC2328和RFC1583的路由计算规则不一致，可能会导致路由环路。为了避免路由环路的发生，RFC2328中提出了RFC1583兼容特性。</p>
<ul>
<li>使能RFC1583兼容后，OSPF采用RFC1583的路由计算规则。</li>
<li>不使能RFC1583兼容时，OSPF采用RFC2328的路由计算规则。</li>
</ul>
<p>OSPF是根据5类LSA来计算外部路由的。RFC1583兼容特性主要用于路由器收到5类LSA后：</p>
<ul>
<li>选择到达产生该LSA的ASBR或该LSA所描述的转发地址（Forwarding Address）的路径；</li>
<li>选择到达相同目的地的外部路径。</li>
</ul>
<p>缺省情况下，OSPF兼容RFC1583。</p>
<h2 id="OSPF是如何工作的？"><a href="#OSPF是如何工作的？" class="headerlink" title="OSPF是如何工作的？"></a>OSPF是如何工作的？</h2><p>OSPF协议路由的计算过程可简单描述如下：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/OSPF.html#section_02">建立邻接关系</a>，过程如下：</p>
<ol>
<li><p>本端设备通过接口向外发送Hello报文与对端设备建立邻居关系。</p>
</li>
<li><p>两端设备进行主&#x2F;从关系协商和DD报文交换。</p>
</li>
<li><p>两端设备通过更新LSA完成链路数据库LSDB的同步。</p>
<p>此时，邻接关系建立成功。</p>
</li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/OSPF.html#section_03">路由计算</a></p>
<p>OSPF采用SPF（Shortest Path First）算法计算路由，可以达到路由快速收敛的目的。</p>
</li>
</ol>
<h3 id="建立邻接关系"><a href="#建立邻接关系" class="headerlink" title="建立邻接关系"></a>建立邻接关系</h3><p>在上述邻居状态机的变化中，有两处决定是否建立邻接关系：</p>
<ul>
<li>当与邻居的双向通讯初次建立时。</li>
<li>当网段中的DR和BDR发生变化时。</li>
</ul>
<p>OSPF在不同网络类型中，OSPF邻接关系建立的过程不同，分为广播网络，NBMA网络，点到点&#x2F;点到多点网络。</p>
<p><strong>在广播网络中建立OSPF****邻接关系</strong></p>
<p>广播链路邻接关系建立过程如图所示。</p>
<p>在广播网络中，DR、BDR和网段内的每一台路由器都形成邻接关系，但DR other之间只形成邻居关系。</p>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=091b70fc4f9a43ecbd0e94a7aaed695c" srcset="/img/loading.gif" lazyload alt="在广播网络中建立OSPF邻接关系" title="在广播网络中建立OSPF邻接关系"><br>在广播网络中建立OSPF邻接关系</p>
<p>如图所示，在广播网络中建立OSPF邻接关系的过程如下：</p>
<ol>
<li><p>建立邻居关系</p>
<ol>
<li>RouterA的一个连接到广播类型网络的接口上激活了OSPF协议，并发送了一个Hello报文（使用<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/%E7%BB%84%E6%92%AD.html" title="组播">组播</a>地址224.0.0.5）。此时，RouterA认为自己是DR路由器（DR&#x3D;1.1.1.1），但不确定邻居是哪台路由器（Neighbors Seen&#x3D;0）。</li>
<li>RouterB收到RouterA发送的Hello报文后，发送一个Hello报文回应给RouterA，并且在报文中的Neighbors Seen字段中填入RouterA的Router ID（Neighbors Seen&#x3D;1.1.1.1），表示已收到RouterA的Hello报文，并且宣告DR路由器是RouterB（DR&#x3D;2.2.2.2），然后RouterB的邻居状态机置为Init。</li>
<li>RouterA收到RouterB回应的Hello报文后，将邻居状态机置为2-way状态，下一步双方开始发送各自的链路状态数据库。</li>
</ol>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=4d039cad0996458293e1ef379d855fed" srcset="/img/loading.gif" lazyload></p>
<p>在广播网络中，两个接口状态是DR Other的路由器之间将停留在此步骤。</p>
</li>
<li><p>主&#x2F;从关系协商、DD报文交换</p>
<ol>
<li><p>RouterA首先发送一个DD报文，宣称自己是Master（MS&#x3D;1），并规定序列号Seq&#x3D;X。I&#x3D;1表示这是第一个DD报文，报文中并不包含LSA的摘要，只是为了协商主从关系。M&#x3D;1说明这不是最后一个报文。</p>
<p>为了提高发送的效率，RouterA和RouterB首先了解对端数据库中哪些LSA是需要更新的，如果某一条LSA在LSDB中已经存在，就不再需要请求更新了。为了达到这个目的，RouterA和RouterB先发送DD报文，DD报文中包含了对LSDB中LSA的摘要描述（每一条摘要可以惟一标识一条LSA）。为了保证在传输的过程中报文传输的可靠性，在DD报文的发送过程中需要确定双方的主从关系，作为Master的一方定义一个序列号Seq，每发送一个新的DD报文将Seq加一，作为Slave的一方，每次发送DD报文时使用接收到的上一个Master的DD报文中的Seq。</p>
</li>
<li><p>RouterB在收到RouterA的DD报文后，将RouterA的邻居状态机改为Exstart，并且回应了一个DD报文（该报文中同样不包含LSA的摘要信息）。由于RouterB的Router ID较大，所以在报文中RouterB认为自己是Master，并且重新规定了序列号Seq&#x3D;Y。</p>
</li>
<li><p>RouterA收到报文后，同意了RouterB为Master，并将RouterB的邻居状态机改为Exchange。RouterA使用RouterB的序列号Seq&#x3D;Y来发送新的DD报文，该报文开始正式地传送LSA的摘要。在报文中RouterA将MS&#x3D;0，说明自己是Slave。</p>
</li>
<li><p>RouterB收到报文后，将RouterA的邻居状态机改为Exchange，并发送新的DD报文来描述自己的LSA摘要，此时RouterB将报文的序列号改为Seq&#x3D;Y+1。</p>
<p>上述过程持续进行，RouterA通过重复RouterB的序列号来确认已收到RouterB的报文。RouterB通过将序列号Seq加1来确认已收到RouterA的报文。当RouterB发送最后一个DD报文时，在报文中写上M&#x3D;0。</p>
</li>
</ol>
</li>
<li><p>LSDB同步（LSA请求、LSA传输、LSA应答）</p>
<ol>
<li><p>RouterA收到最后一个DD报文后，发现RouterB的数据库中有许多LSA是自己没有的，将邻居状态机改为Loading状态。此时RouterB也收到了RouterA的最后一个DD报文，但RouterA的LSA，RouterB都已经有了，不需要再请求，所以直接将RouterA的邻居状态机改为Full状态。</p>
</li>
<li><p>RouterA发送LSR报文向RouterB请求更新LSA。RouterB用LSU报文来回应RouterA的请求。RouterA收到后，发送LSAck报文确认。</p>
<p>上述过程持续到RouterA中的LSA与RouterB的LSA完全同步为止，此时RouterA将RouterB的邻居状态机改为Full状态。当路由器交换完DD报文并更新所有的LSA后，此时邻接关系建立完成。</p>
</li>
</ol>
</li>
</ol>
<p><strong>在NBMA<strong><strong>网络中建立OSPF</strong></strong>邻接关系</strong></p>
<p>NBMA网络和广播网络的邻接关系建立过程只在交换DD报文前不一致，如图中的蓝色标记。</p>
<p>在NBMA网络中，所有路由器只与DR和BDR之间形成邻接关系。</p>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=f06293d927c5461bb6691e28633d71f9" srcset="/img/loading.gif" lazyload alt="在NBMA网络中建立OSPF邻接关系" title="在NBMA网络中建立OSPF邻接关系"><br>在NBMA网络中建立OSPF邻接关系</p>
<p>如图所示，在NBMA网络中建立OSPF邻接关系的过程如下：</p>
<ol>
<li><p>建立邻居关系</p>
<ol>
<li>RouterB向RouterA的一个状态为Down的接口发送Hello报文后，RouterB的邻居状态机置为Attempt。此时，RouterB认为自己是DR路由器（DR&#x3D;2.2.2.2），但不确定邻居是哪台路由器（Neighbors Seen&#x3D;0）。</li>
<li>RouterA收到Hello报文后将邻居状态机置为Init，然后再回复一个Hello报文。此时，RouterA同意RouterB是DR路由器（DR&#x3D;2.2.2.2），并且在Neighbors Seen字段中填入邻居路由器的Router ID（Neighbors Seen&#x3D;2.2.2.2）。</li>
</ol>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=4d039cad0996458293e1ef379d855fed" srcset="/img/loading.gif" lazyload></p>
<p>在NBMA网络中，两个接口状态是DR Other的路由器之间将停留在此步骤。</p>
</li>
<li><p>主&#x2F;从关系协商、DD报文交换过程同广播网络的邻接关系建立过程。</p>
</li>
<li><p>LSDB同步（LSA请求、LSA传输、LSA应答）过程同广播网络的邻接关系建立过程。</p>
</li>
</ol>
<p>*<em>在点到点&#x2F;<strong><strong>点到多点网络中建立OSPF</strong></strong>邻接关系</em>*</p>
<p>在点到点&#x2F;点到多点网络中，邻接关系的建立过程和广播网络一样，唯一不同的是不需要选举DR和BDR，DD报文是组播发送的。</p>
<h3 id="路由计算"><a href="#路由计算" class="headerlink" title="路由计算"></a>路由计算</h3><p>OSPF采用SPF（Shortest Path First）算法计算路由，可以达到路由快速收敛的目的。</p>
<p>OSPF协议使用链路状态通告LSA描述网络拓扑，即有向图。Router LSA描述路由器之间的链接和链路的属性。路由器将LSDB转换成一张带权的有向图，这张图便是对整个网络拓扑结构的真实反映。各个路由器得到的有向图是完全相同的。如图所示。</p>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=534098449c804d73a7bfc7aea26d364a" srcset="/img/loading.gif" lazyload alt="由LSDB生成带权有向图" title="由LSDB生成带权有向图"><br>由LSDB生成带权有向图</p>
<p>每台路由器根据有向图，使用SPF算法计算出一棵以自己为根的最短路径树，这棵树给出了到自治系统中各节点的路由。如图所示。</p>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=d531aadda16c498aae39b0791d2e157c" srcset="/img/loading.gif" lazyload alt="最小生成树" title="最小生成树"><br>最小生成树</p>
<p>当OSPF的链路状态数据库LSDB发生改变时，需要重新计算最短路径，如果每次改变都立即计算最短路径，将占用大量资源，并会影响路由器的效率，通过调节SPF的计算间隔时间，可以抑制由于网络频繁变化带来的占用过多资源。缺省情况下，SPF时间间隔为5秒钟。</p>
<p>具体的计算过程如下：</p>
<ol>
<li><p>计算区域内路由。</p>
<p>Router LSA和Network LSA可以精确的描述出整个区域内部的网络拓扑，根据SPF算法，可以计算出到各个路由器的最短路径。根据Router LSA描述的与路由器的网段情况，得到了到达各个网段的具体路径。</p>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=4d039cad0996458293e1ef379d855fed" srcset="/img/loading.gif" lazyload></p>
<p>在计算过程中，如果有多条等价路由，SPF算法会将所有等价路径都保留在LSDB中。</p>
</li>
<li><p>计算区域外路由。</p>
<p>从一个区域内部看，相邻区域的路由对应的网段好像是直接连接在ABR上，而到ABR的最短路径已经在上一过程中计算完毕，所以直接检查Network Summary LSA，就可以很容易得到这些网段的最短路径。另外，ASBR也可以看成是连接在ABR上，所以ASBR的最短路径也可以在这个阶段计算出来。</p>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=4d039cad0996458293e1ef379d855fed" srcset="/img/loading.gif" lazyload></p>
<p>如果进行SPF计算的路由器是ABR，那么只需要检查骨干区域的Network Summary LSA。</p>
</li>
<li><p>计算自治系统外路由。</p>
<p>由于自治系统外部的路由可以看成是直接连接在ASBR上，而到ASBR的最短路径在上一过程中已经计算完毕，所以逐条检查AS External LSA就可以得到到达各个外部网络的最短路径。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/OSPF.html">https://info.support.huawei.com/info-finder/encyclopedia/zh/OSPF.html</a></p>
</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/network/" class="category-chain-item">network</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/network/">#network</a>
      
        <a href="/tags/datacom/">#datacom</a>
      
        <a href="/tags/ospf/">#ospf</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>什么是OSPF?</div>
      <div>https://songxwn.com/OSPF-Basic/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Song</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年7月30日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2023年7月30日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/BGP_EVPN_Basic/" title="什么是EVPN？">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">什么是EVPN？</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/Veeam12.202307/" title="Veeam Backup Replication 12 7月更新安装">
                        <span class="hidden-mobile">Veeam Backup Replication 12 7月更新安装</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments">
      
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script>
        Fluid.utils.loadComments('#disqus_thread', function() {
          Fluid.utils.createCssLink('https://lib.baomitu.com/disqusjs/1.3.0/disqusjs.css');
          Fluid.utils.createScript('https://lib.baomitu.com/disqusjs/1.3.0/disqus.js', function() {
            new DisqusJS({
              shortname: 'songxwn',
              apikey: ''
            });
          });
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
      <div class="col-lg-7 mx-auto nopadding-x-md">
        <div class="container custom mx-auto">
          <a href="https://www.foreverblog.cn/go.html" target="_blank"> <img src="https://img.foreverblog.cn/wormhole_1_tp.gif" alt="" style="width:auto;height:32px;" title="穿梭虫洞-随机访问十年之约友链博客"></a>,<a href="https://www.vultr.com/?ref=7199488" target="_blank"> <img src="https://www.vultr.com/media/logo_ondark.svg" alt="" style="width:auto;height:32px;" title="注册vultr获取免费10美元体验额度"></a>,<a href="https://url.cn/eTx2WPml" target="_blank"> <img src="https://s3.bmp.ovh/imgs/2023/05/06/989aea4d82987ca9.png" alt="" style="width:auto;height:32px;" title="【腾讯云】云服务器、云数据库、COS、CDN、短信等云产品特惠热卖中"></a>
        </div>
      </div>
    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  

<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/DynamicRibbon.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
